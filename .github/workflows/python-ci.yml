name: Delphi Python Tests

on:
  push:
    branches: [ edge, stable ]
  pull_request:
    branches: [ edge, stable ]

jobs:
  test:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: 1. Free up disk space on runner
      run: |
        echo "Starting disk cleanup..."
        df -h
        sudo rm -rf /usr/share/dotnet /opt/ghc /usr/local/lib/android /usr/local/share/powershell
        echo "Disk space after cleanup:"
        df -h

    - name: 2. Create .env file for CI
      run: |
        if [ -f "test.env" ]; then
          cp test.env .env
          echo "Using test.env for CI."
        else
          echo "::error::test.env file not found!"
          exit 1
        fi
        
        # Add hostnames for container-to-container networking
        # The 'delphi' service in 'docker-compose.test.yml' reads these
        echo "POSTGRES_HOST=postgres" >> .env
        echo "DYNAMODB_ENDPOINT=http://dynamodb:8000" >> .env
        echo "AWS_S3_ENDPOINT=http://minio:9000" >> .env

    - name: 3. Build Docker images
      run: |
        # Build all services in the test file (including delphi)
        docker compose -f docker-compose.test.yml --env-file .env build

    - name: 4. Start all services
      run: |
        # Start all services (including delphi) in detached mode
        # The 'delphi' container will start and run 'tail -f /dev/null'
        docker compose -f docker-compose.test.yml --env-file .env up -d
        
        echo "Waiting for services to be healthy..."
        sleep 20 # Wait for containers to start
        docker compose -f docker-compose.test.yml ps

    - name: 5. Check service health
      run: |
        # Wait for postgres to be ready
        echo "Checking postgres..."
        docker compose -f docker-compose.test.yml exec -T postgres \
          bash -c 'until pg_isready -U $POSTGRES_USER; do sleep 5; done'
        echo "Postgres is ready."

    - name: 6. Run Delphi Pytest
      run: |
        echo "Copying test files into container..."
        docker compose -f docker-compose.test.yml cp delphi/tests delphi:/app/tests
        docker compose -f docker-compose.test.yml cp delphi/real_data delphi:/app/real_data

        echo "Running tests and generating coverage report..."
        docker compose \
          -f docker-compose.test.yml \
          --env-file .env \
          exec -T \
          -e AWS_DEFAULT_REGION=us-east-1 \
          -e AWS_REGION=us-east-1 \
          -e AWS_ACCESS_KEY_ID=dummy \
          -e AWS_SECRET_ACCESS_KEY=dummy \
          delphi \
          bash -c " \
            set -e; \
            echo '--- Setting up DynamoDB Tables ---'; \
            python create_dynamodb_tables.py --region us-east-1; \
            echo '--- Installing Pytest & Coverage tools ---'; \
            pip install pytest pytest-cov coverage; \
            echo '--- Running Pytest ---'; \
            export PYTHONPATH=\$PYTHONPATH:/app; \
            pytest --cov=polismath --cov-report=xml:/app/coverage.xml /app/tests; \
            echo '--- Generating Coverage Comment Text ---'; \
            python - <<'END_SCRIPT'
            import xml.etree.ElementTree as ET
            import sys
            import textwrap

            # Dedent the main script body to fix YAML indentation
            script_body = """
            try:
                tree = ET.parse('/app/coverage.xml')
                root = tree.getroot()

                lines = [
                    "| File | Stmts | Miss | Cover |",
                    "|------|-------|------|-------|"
                ]
                
                total_statements = 0
                total_missed = 0
                
                packages = root.find('packages')
                if packages is None:
                    print("Could not find 'packages' tag in coverage.xml", file=sys.stderr)
                    sys.exit(1)

                all_files = []
                for package in packages.findall('package'):
                    classes = package.find('classes')
                    if classes is None:
                        continue
                    
                    for cls in classes.findall('class'):
                        filename = cls.get('filename') # This is the path
                        line_rate = float(cls.get('line-rate', '0'))
                        
                        lines_node = cls.find('lines')
                        if lines_node is None:
                            continue
                            
                        lines_valid = 0
                        lines_covered = 0
                        
                        for line in lines_node.findall('line'):
                            lines_valid += 1
                            if int(line.get('hits', '0')) > 0:
                                lines_covered += 1
                        
                        if lines_valid == 0:
                            continue # Skip files with no executable statements

                        lines_missed = lines_valid - lines_covered
                        total_statements += lines_valid
                        total_missed += lines_missed
                        
                        coverage_percent = line_rate * 100
                        all_files.append((filename, lines_valid, lines_missed, coverage_percent))

                # Sort files alphabetically
                all_files.sort(key=lambda x: x[0])
                
                for f in all_files:
                    lines.append(f"| {f[0]} | {f[1]} | {f[2]} | {f[3]:.0f}% |")

                if total_statements > 0:
                    total_coverage = ((total_statements - total_missed) / total_statements) * 100
                    lines.append(f"| **Total** | **{total_statements}** | **{total_missed}** | **{total_coverage:.0f}%** |")
                else:
                    lines.append("| **Total** | **0** | **0** | **N/A** |")

                with open('/app/coverage-comment.md', 'w') as f:
                    f.write('\n'.join(lines))
                    
            except Exception as e:
                print(f"Error parsing coverage.xml: {e}", file=sys.stderr)
                with open('/app/coverage-comment.md', 'w') as f:
                    f.write(f"Error generating coverage report: {e}")
                sys.exit(1)
            """

            try:
                exec(textwrap.dedent(script_body))
            except Exception as e:
                print(f"Error in wrapper: {e}", file=sys.stderr)
                sys.exit(1)
            END_SCRIPT
          "

    - name: 7. Copy coverage report from container
      if: success()
      run: |
        echo "Copying coverage-comment.md from delphi container..."
        docker compose -f docker-compose.test.yml cp delphi:/app/coverage-comment.md .

    - name: 8. Post Coverage Comment
      if: success() && github.event_name == 'pull_request'
      uses: actions/github-script@v6
      with:
        github-token: ${{ secrets.GITHUB_TOKEN }}
        script: |
          const fs = require('fs');
          const commentBody = fs.readFileSync('coverage-comment.md', 'utf8');
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: "## Coverage Report\n\n" + commentBody
          });

    - name: 9. Show service logs on failure
      if: failure()
      run: |
        echo "=== Delphi service logs ==="
        docker compose -f docker-compose.test.yml logs delphi || true
        echo "=== Postgres service logs ==="
        docker compose -f docker-compose.test.yml logs postgres || true
        echo "=== DynamoDB service logs ==="
        docker compose -f docker-compose.test.yml logs dynamodb || true

    - name: 10. Clean up services
      if: always()
      run: |
        echo "Cleaning up services..."
        docker compose -f docker-compose.test.yml down -v